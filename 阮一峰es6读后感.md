###Es6入门读后感
####1 let命令
 Es6中新增了let命令，用来声明变量。它的用法类似于var ,但是所声明的变量，只在let命令所在的代码块内有效。
 { let a =10;var b= 1;}
 a//Reference Error :a is not defined
 b//1
 上面代码在代码块中，分别用let 和var 声明了两个变量。然后在代码块之外调用者两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。
 let的出现时js有了块级作用域。
 let不像 var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。
 ###暂时性死区
 只要块级作用域内存在Let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。
 var  tmp =123;
 if (){
  tmp="abc"
  let tmp
 }
在以上的代码中，存在全局变量tmp,但是块级作用域内let 又声明了一个局部变量tmp,导致后置绑定这个块级作用域，所以在let 声明变量前，对tmp赋值会报错。
es6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量从一开始就形成了封闭的作用域。凡是在声明之前就使用这些变量，就会报错。
总之，在代码块内，使用let命令声明变量之前，该变量都是可以不可用的在语法上，称为暂时性死区。
暂时性死区也意味着typeof不再是一个百分百安全的操作
es6  规定暂时性死区和不存在变量提升，主要是为了减少裕兴是错误，放置变量声明是就使用这个变量，从而导致变量意料之外的行为。
###const 命令
const 声明一个只读的常量，一旦声明，常量的值就不能改变。
const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用 
对于符合类型的变量，变量名不指向数据，而好似指向数据所在的地址。const命令指示保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量时必须要非常小心。
###全局对象的属性
全局对象是最顶层的对象，在浏览器环境中值得是window 对象 ，在Node.js指的是global对象。ES5中，全局对象的属性与全局变量是等价的
 window.a=1;
 a //1
 a=2;
 window.a//2
上面的代码中，全局对象的属性赋值与全局变量的赋值是同一件事。
未声明的全局变量，自动成为全局对象window的属性，这被认为是JavaScript语言最大的败笔之一。
ES6为了改变这一点，一方面规定，为了保持兼容性，var 命令和funciton命令声明的全局变量，依旧是全局对象的属性; 另一方面规定，let命令、const命令classm命令声明的全局变量，不属于全局对象的属性。也就是说从ES6开始，全局变量将逐步与全局对象的属性脱钩

